#include <iostream>
using namespace std;
// 基类 Base
class Base 
{
public:
    // 虚析构函数
    virtual ~Base()
    {
        cout << "Base 的析构函数被调用" << std::endl;
    }
};

// 派生类 Derived
class Derived : public Base
{
public:
    // 覆盖基类的虚析构函数
    ~Derived() override
    {
        cout << "Derived 的析构函数被调用" << endl;
        // 在这里可以进行派生类特有的清理工作
    }
};

int main() 
{
    // 使用基类指针指向派生类对象
    Base* basePtr = new Derived();

    // 删除对象，会调用派生类的析构函数
    delete basePtr;

    return 0;
}

/*
虚析构函数的引入涉及到对象销毁的问题。通常，当一个对象的生命周期结束，
它会被销毁，而其析构函数会被调用。在继承体系中，如果基类的析构函数不是虚函数，
当使用基类指针指向派生类对象并通过这个指针删除对象时，只会调用基类的析构函数，
而不会调用派生类的析构函数。

这可能导致资源泄漏，因为如果派生类有自己的资源（比如动态分配的内存），这些资源将不会被释放。
通过将析构函数声明为虚函数，我们可以实现正确的销毁对象。
这是因为虚析构函数的存在使得在删除基类指针时，会根据实际对象的类型来调用相应的析构函数，
从而确保了派生类的析构函数被正确执行。这种机制对于基类指针指向派生类对象的多态性是非常重要的。
*/


